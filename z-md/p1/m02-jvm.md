### 1. JVM内存模型

1. 栈：又称方法栈，线程私有的，线程执行方法时都会创建一个栈帧，用来存储局部变量表、操作栈、动态链接、方法出口等信息，调用方法时入栈，方法返回时出栈。
2. 本地方法栈：与栈类似也是用来保存方法的信息，但它不是为Java方法服务，而是Native方法（C语言）。
3. 程序计数器：保存当前线程执行的字节码位置，作用是当操作系统分配CPU资源，线程切换时每个线程就需要记录下一条要运行的指令位置。
4. 堆：存放对象实例和数组，JVM内存管理最大的一块，被线程共享。
5. 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量。

线程独占：栈、本地方法栈、程序计数器  
线程共享：堆、方法区

### 2. Java为什么可以跨平台？

JVM是运行在操作系统之上的，它与硬件没有直接的交互。

Java源文件通过编译器，能够生成相应的.Class文件，也就是字节码文件，而字节码文件又通过Java虚拟机中的解释器，编译成特定机器上的机器码。  
如下：

1. Java源文件 -> 编译器 -> 字节码文件
2. 字节码文件 -> JVM -> 机器码

### 3. 垃圾回收机制

堆的空间分配

- 新生代(1/3堆空间)
  - Eden区(8/10)
  - From区(1/10)
  - To区(1/10)
- 老年代(2/3堆空间)

Eden区是Java新对象的出生地，From区保存上一次GC的幸存者。不过大对象直接进入老年代，避免大量的内存拷贝。

GC分为两种，新生代用的叫MinorGC，老年代的用叫MajorGC。

- MinorGC采用的算法：复制算法
- MajorGC采用的算法：标记-清除算法
- MinorGC 和 MajorGC 一起叫 FullGC

复制算法：  
首先，把Eden区和From区中存活的对象复制到To区，同时把这些对象的年龄+1，如果有对象的年龄到达了老年的标准则复制到老年区。  
然后，清空Eden区和From区中的对象。  
最后，To区和From区互换（原To区成为下一次GC时的From区）。

标记-清除算法：  
标记阶段标记出所有需要回收的对象，然后将存活对象移到一端，剩下的全部清除，避免了内存碎片化。

### 4. 如何判断对象是否要被回收?

判断对象是否存活一般有两种方式：

- 引用计数法：每个对象都有一个引用计数属性，新增一个引用时计数加1，释放后计数减1，计数为0时可以回收。缺点时无法解决对象相互引用的问题。
- 可达性分析：从GC Root开始向下搜索，搜索走过的路径称为引用链。当一个对象到GC Root不可达时，可以被回收。

### 5. Java8之后 PermGen Space(永久代)有什么变动？

Java8之后，永久代已经被移除，被另一个元空间的区域所取代。元空间本质和永久代类似，最大的区别是：元空间并不在虚拟机中，而是使用本地内存。

注：永久代和元空间指的都是对方法区的落地实现。


### 6. OOM问题常见的原因？

1. 内存加载的数据量太大，一次性从数据库取了太多的数据。
2. 集合类中有对象的引用，使用后未清空，GC不能进行回收。
3. 代码中存在循环产生过多的重复对象。
4. 启动参数堆内存值太小。


### 7. 类加载机制

分为五个阶段： 加载、验证、准备、解析、初始化

加载：会在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据入口。（获取的来源不只是Class文件，还有jar包、动态代理生成，比如JSP文件）

验证：确保Class文件的字节流中信息符合当前虚拟机的要求，并不会危害虚拟机自身的安全。

准备：正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量的内存空间。

解析：虚拟机将常量池中的符号引用替换为直接引用的过程。

初始化： 完成静态块执行以及静态变量的赋值，先初始化父类再初始化当前类，只有对类主动使用时才会初始化。


注：符号引用就是在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。如果有了
直接引用，就说明目标类一定被加载到了内存中。


### 8. 什么是双亲委派机制？

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在JVM中的唯一性，类加载器共有3种。
1. 启动类加载器（Bootstrap ClassLoader）：负责加载JVM基础核心类库，在JAVA_HOME\lib目录中。
2. 扩展类加载器（Extension ClassLoader）：负责加载JVM扩展类，比如swing系列、内置的 js 引擎、xml 解析器 等。
3. 应用程序类加载器（Application ClassLoader）：是直接面向我们用户的加载器，它会加载 Classpath 环境变量里定义的路径中的 jar 包和目录。我们自己编写的代码以及使用的第三方 jar 包通常都是由它来加载的。


类加载器继承关系：  
启动类加载器  <<  扩展类加载器 << 应用程序类加载器 << 自定义加载器    

双亲委派机制：  
一个类要加载时，先通过Class对象中的classLoader属性决定由哪个类加载器加载，然后这个类加载器首先不会自己去加载，而是把这个请求委派给父类加载器完成，每一层的类加载器都是如此，传到顶层的启动类加载器中无法完成加载时，再反馈给子类去加载。  
优点：1. 避免类的重复加载  2. 避免Java的核心api被篡改

