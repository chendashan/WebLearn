### JVM内存模型

1. 栈：又称方法栈，线程私有的，线程执行方法时都会创建一个栈帧，用来存储局部变量表、操作栈、动态链接、方法出口等信息，调用方法时入栈，方法返回时出栈。
2. 本地方法栈：与栈类似也是用来保存方法的信息，但它不是为Java方法服务，而是Native方法（C语言）。
3. 程序计数器：保存当前线程执行的字节码位置，作用是当操作系统分配CPU资源，线程切换时每个线程就需要记录下一条要运行的指令位置。
4. 堆：存放对象实例和数组，JVM内存管理最大的一块，被线程共享。
5. 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量。

线程独占：栈、本地方法栈、程序计数器  
线程共享：堆、方法区

### Java为什么可以跨平台？

JVM是运行在操作系统之上的，它与硬件没有直接的交互。

Java源文件通过编译器，能够生成相应的.Class文件，也就是字节码文件，而字节码文件又通过Java虚拟机中的解释器，编译成特定机器上的机器码。  
如下：

1. Java源文件 -> 编译器 -> 字节码文件
2. 字节码文件 -> JVM -> 机器码

### 垃圾回收机制

堆的空间分配

- 新生代(1/3堆空间)
  - Eden区(8/10)
  - From区(1/10)
  - To区(1/10)
- 老年代(2/3堆空间)

Eden区是Java新对象的出生地，From区保存上一次GC的幸存者。不过大对象直接进入老年代，避免大量的内存拷贝。

GC分为两种，新生代用的叫MinorGC，老年代的用叫MajorGC。

- MinorGC采用的算法：复制算法
- MajorGC采用的算法：标记-清除算法
- MinorGC 和 MajorGC 一起叫 FullGC

复制算法：  
首先，把Eden区和From区中存活的对象复制到To区，同时把这些对象的年龄+1，如果有对象的年龄到达了老年的标准则复制到老年区。  
然后，清空Eden区和From区中的对象。  
最后，To区和From区互换（原To区成为下一次GC时的From区）。

标记-清除算法：  
标记阶段标记出所有需要回收的对象，然后将存活对象移到一端，剩下的全部清除，避免了内存碎片化。

### 如何判断对象是否要被回收?

判断对象是否存活一般有两种方式：

- 引用计数法：每个对象都有一个引用计数属性，新增一个引用时计数加1，释放后计数减1，计数为0时可以回收。缺点时无法解决对象相互引用的问题。
- 可达性分析：从GC Root开始向下搜索，搜索走过的路径称为引用链。当一个对象到GC Root不可达时，可以被回收。

### Java8之后 PermGen Space(永久代)有什么变动？

Java8之后，永久代已经被移除，被另一个元空间的区域所取代。元空间本质和永久代类似，最大的区别是：元空间并不在虚拟机中，而是使用本地内存。

注：永久代和元空间指的都是对方法区的落地实现。
